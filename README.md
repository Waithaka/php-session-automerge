PHP Session Handler with Auto-Merge
--------------------------

*  No locking means extremely fast and non-blocking requests
*  Auto-merge reduces the chance of data corruption and merge conflicts
*  Ability to provide custom logic for resolving application-specific merge conflicts
*  Supports Memcached and Redis out of the box, but easy to extend to other storage mechanisms

Basic Usage
--------------------------
```php
<?php
use EduCom\SessionAutomerge\SessionhandlerMemcached;

$memcached = new Memcached;
$memcached->addServer('localhost', 11211);

$handler = new SessionhandlerMemcached($memcached);

// Specify options if needed
$handler->ttl = 7200; // Cache for 2 hours (default is 1 hour)

// Set the save handler
session_set_save_handler($handler);
```

#### Optional Settings

*  `ttl` - Number of seconds to keep a session active. Defaults to 3600 (1 hour)
*  `prefix` - A prefix to add to all session ids. Defaults to `session_`
*  `readonly` - If true, changes to `$_SESSION` during the request will be ignored


Recommended PHP Settings
----------------------------
Use HTTPS site-wide to protect your user's sessions. (check out https://letsencrypt.org/ for free SSL certificates).

Enable the following `php.ini` settings for more security:
*  `session.cookie_secure` - protects again session hijacking (Note: requires site-wide HTTPS)
*  `session.cookie_httponly` - protects against XSS attacks in some browsers
*  `session.use_strict_mode` - protects against session fixation attacks

Do not store objects in the session. Stick to primitive data types. This will reduce chances of future bugs and make your sessions portable

Extending and Adding Conflict Resolution
-----------------------------------------
It's easy to extend one of the session handler classes and add your own custom conflict resoltuion code:

*  `$key` is the array key in  `$_SESSION` that has a conflict
*  `$initial` was the intial value of the key at the start of the current request
*  `$new` is the new value of the key at the end of the current request
*  `$external` is the latest value of the key from the database (set in a different request)

A value of `null` means it does not exist (e.g. if `$external` is null, the value was deleted in an external request).

```php
<?php
use EduCom\SessionAutomerge\SessionHandlerMemcached;

class MySessionHandler extends SessionHandlerMemcached {
    public function resolveConflict($key, $initial, $new, $external) {
        // Special handling for a known session key 'items_viewed'
        if($key === 'items_viewed') {
            // Get the new items added during this request
            $items = array_diff($initial, $new);
            
            // Merge these newly added items with the external change
            $merged = array_merge($external, $items);
            
            return $merged;
        }
        
        // Fall back to default resolution method
        return parent::resolveConflict($key,$initial,$new,$external); // TODO: Change the autogenerated stub
    }
}
```

Adding New Storage Mechanism
----------------------------

If you want to use something other than Redis or Memcached, it's easy to extend the base class.

Here's a fully working example of storing sessions in the filesystem.

```php
<?php
use EduCom\SessionAutomerge\SessionHandlerBase;

// TODO: support ttl
class FileSessionHandler extends SessionHandlerBase {
    public $path = '/tmp/';
    
    public function __construct($path='/tmp/') {
        $this->path = $path;
    }
    
    public function set($key, array $session_data) {
        file_put_contents($this->path.$key, serialize($session_data));
    }
    public function get($key) {
        $raw = file_get_contents($this->path.$key);
        return unserialize($raw);
    }
    public function delete($key) {
        unlink($this->path.$key);
    }
}
```